{
    "collab_server" : "",
    "contents" : "#' Scoped versions of filter_qc\n#' \n#' \\code{filter_all_qc}, \\code{filter_at_qc}, and \\code{filter_if_qc} return\n#'   identical objects as \\code{filter_all}, \\code{filter_at}, and \n#'   \\code{filter_if} respectively, except that they automatically print the\n#'   number of cases (i.e., rows) that do not meet the filter conditions and \n#'   that were thus dropped.\n#' \n#' @inheritParams dplyr::filter_all\n#'\n#' @param .group_check a logical value, that when TRUE, will print a table with\n#' each group variable and columns called \"n_rows_dropped\" and \"percent_dropped\" \n#' that together indicate, for each group, how many row were dropped when \n#' performing filter. Default is FALSE, to avoid excess printing. If data is not\n#' grouped and .group_check = T, then an error is thrown.\n#' \n#' @return An object of the same class as \\code{.data}. This object will be\n#'   identical to that which is returned when running the respective scoped \n#'   version of \\code{dplyr::filter}.\n#' \n#' @seealso \\code{\\link[dplyr]{filter_all}}, and \\code{\\link[dplyr]{filter_at}},\n#'   or \\code{\\link[dplyr]{filter_if}}\n#' \n#' @examples \n#' practice_data <- \n#'   data.frame(\n#'     A = 1:12, \n#'     B = 6:17, \n#'     C = 8:19, \n#'     G = c(rep(c(1, 2), each = 6))\n#'   )\n#' \n#' \n#' # Scoped filtering\n#' filter_all_qc(practice_data, all_vars(. > 9))\n#' filter_at_qc(practice_data, vars(B, C), any_vars(. > 9))\n#' filter_if_qc(practice_data, is.integer, all_vars(. > 3))\n#' \n#' # With grouped data and setting .group_check = T, you can see how many rows\n#' # were dropped per group. Note that this will print a large table if you have \n#' # a lot of groups.\n#' grouped_data <- group_by(practice_data, G)\n#' filter_all_qc(grouped_data, dplyr::all_vars(. > 9), .group_check = T)\n#' \n#' @name filter_all_qc\nNULL\n\n\n\n# HELPER FUNCTIONS -------------------------------------------------------------\n\n# Function to print number of dropped rows per group (for grouped data only)\ndropped_grp_fn <- function(init_data, final_data) {\n  \n  # Number of final rows per group\n  final_grp <- dplyr::tally(final_data, wt = NULL)\n  names(final_grp)[length(names(final_grp))] <- \".final.\"\n  \n  # Number of intial rows per group\n  init_grp <- dplyr::tally(init_data, wt = NULL)\n  names(init_grp)[length(names(init_grp))] <- \".initial.\"\n  \n  # Merging togther and calculating rows dropped\n  merged_grp <- suppressMessages(dplyr::left_join(init_grp, final_grp))\n  merged_grp <- dplyr::mutate(\n    merged_grp, \n    .final. = ifelse(is.na(.final.), 0, .final.),\n    .diff. = .initial. - .final.,\n    .prop. = paste0(round(100 * .diff. / .initial., 1), \"%\")\n  )\n  merged_grp <- dplyr::select(merged_grp, -.final., -.initial.)\n  names(merged_grp)[(length(names(merged_grp)) - 1):length(names(merged_grp))] <- \n    c(\"n_rows_dropped\", \"percent_dropped\")\n  \n  # Printing grouped filter diagnostics and returning filtered data\n  message(\"\\n\", \"NUMBER OF ROWS DROPPED BY GROUP:\")\n  print.data.frame(merged_grp)\n  \n}\n  \n  \n\n# EXPORTED FUNCTIONS -----------------------------------------------------------\n\n#' @rdname filter_all_qc\n#' @export\nfilter_all_qc <- function(.tbl, .vars_predicate, .group_check = F) {\n  \n  # Check to make sure data is grouped if .group_check = T\n  if (.group_check == T & is.null(attr(.tbl, \"vars\"))) {\n    stop(\"Data is not grouped, so you cannot have .group_check = T\")\n  }\n  \n  # Preparing arguments to pass to function\n  .args <- list(\".tbl\" = .tbl, \".vars_predicate\" = .vars_predicate)\n  \n  # Performing filter and counting remaining rows\n  out <- do.call(dplyr::filter_all, .args)\n  out_nogrp <- dplyr::ungroup(out)\n  final_rows <- dplyr::tally(out_nogrp, wt = NULL)\n  \n  # Counting initial rows\n  init_nogrp <- dplyr::ungroup(.tbl)\n  init_rows <- dplyr::tally(init_nogrp, wt = NULL)\n  \n  # Printing filter diagnostics and returning filtered data\n  message(\n    init_rows - final_rows, \n    \" Rows dropped (\",\n    round(100 * (init_rows - final_rows) / init_rows, 1),\n    \"%), after filtering on: \",\n    deparse(substitute(.vars_predicate))\n  )\n  \n  if (.group_check == T) dropped_grp_fn(init_data = .tbl, final_data = out)\n\n  return(out)\n\n}\n\n#' @rdname filter_all_qc\nfilter_at_qc <- function(.tbl, .vars, .vars_predicate, .group_check = F) {\n  \n  # Check to make sure data is grouped if .group_check = T\n  if (.group_check == T & is.null(attr(.tbl, \"vars\"))) {\n    stop(\"Data is not grouped, so you cannot have .group_check = T\")\n  }\n  \n  # Preparing arguments to pass to function\n  .args <- list(\".tbl\" = .tbl, \".vars\" = .vars, \".vars_predicate\" = .vars_predicate)\n  \n  # Performing filter and counting remaining rows\n  out <- do.call(dplyr::filter_at, .args)\n  out_nogrp <- dplyr::ungroup(out)\n  final_rows <- dplyr::tally(out_nogrp, wt = NULL)\n  \n  # Counting initial rows\n  init_nogrp <- dplyr::ungroup(.tbl)\n  init_rows <- dplyr::tally(init_nogrp, wt = NULL)\n  \n  # Printing filter diagnostics and returning filtered data\n  message(\n    init_rows - final_rows, \n    \" Rows dropped (\",\n    round(100 * (init_rows - final_rows) / init_rows, 1),\n    \"%), after filtering on: \",\n    deparse(substitute(.vars_predicate))\n  )\n  \n  if (.group_check == T) dropped_grp_fn(init_data = .tbl, final_data = out)\n  \n  return(out)\n  \n}\n\n#' @rdname filter_all_qc\nfilter_if_qc <- function(.tbl, .predicate, .vars_predicate, .group_check = F) {\n  \n  # Check to make sure data is grouped if .group_check = T\n  if (.group_check == T & is.null(attr(.tbl, \"vars\"))) {\n    stop(\"Data is not grouped, so you cannot have .group_check = T\")\n  }\n  \n  # Preparing arguments to pass to function\n  .args <- list(\".tbl\" = .tbl, \".predicate\" = .predicate, \".vars_predicate\" = .vars_predicate)\n  \n  # Performing filter and counting remaining rows\n  out <- do.call(dplyr::filter_if, .args)\n  out_nogrp <- dplyr::ungroup(out)\n  final_rows <- dplyr::tally(out_nogrp, wt = NULL)\n  \n  # Counting initial rows\n  init_nogrp <- dplyr::ungroup(.tbl)\n  init_rows <- dplyr::tally(init_nogrp, wt = NULL)\n  \n  # Printing filter diagnostics and returning filtered data\n  message(\n    init_rows - final_rows, \n    \" Rows dropped (\",\n    round(100 * (init_rows - final_rows) / init_rows, 1),\n    \"%), after filtering on: \",\n    deparse(substitute(.vars_predicate))\n  )\n  \n  if (.group_check == T) dropped_grp_fn(init_data = .tbl, final_data = out)\n  \n  return(out)\n  \n}",
    "created" : 1519656117989.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2574910899",
    "id" : "4BFBA454",
    "lastKnownWriteTime" : 1519656381,
    "last_content_update" : 1519656381863,
    "path" : "~/GitHub/reviewr_2/R/filter_scoped_qc.R",
    "project_path" : "R/filter_scoped_qc.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}