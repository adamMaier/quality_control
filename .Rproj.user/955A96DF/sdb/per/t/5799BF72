{
    "collab_server" : "",
    "contents" : "#' Scoped versions of summarize_qc\n#' \n#' \\code{summarize_all_qc}, \\code{summarize_at_qc}, and \\code{summarize_if_qc}\n#' are used exactly the same as \\code{dplyr::summarize_all},\n#' \\code{dplyr::summarize_at}, and \\code{dplyr::summarize_if}, and require \n#' all of the same arguments and return identical objects. The only difference\n#' is that the \\code{_qc} versions print a message indicating the number of NA\n#' or INFinite values created in the new summary variable(s). This is most\n#' useful when using on a grouped data frame.\n#' \n#' @section Grouping:\n#'   All functions work with grouped data.\n#'\n#' @section summarize vs. summarise:\n#'   There are \\code{_qc} versions of \\code{summarize} and \\code{summarise}.\n#'   But this is America, use a z!\n#'     \n#' @inheritParams dplyr::summarise_all\n#' \n#' @param .group_check a logical value, that when TRUE, will print a table with\n#' each group variable and a column called \"missing_vars\" that lists which \n#' variables are missing from the summarized data for each group. Only groups \n#' with at least one missing variable are listed. This has no effect on the \n#' returned object, and only prints information. Default is FALSE, to avoid\n#' excess printing. If data is not grouped and .group_check = T, then an error \n#' is thrown.\n#'   \n#' @return An object of the same class as \\code{.data}. This object will be\n#'   identical to that which is returned when running the scoped variants of\n#'   \\code{dplyr::summarize}.\n#' \n#' @seealso \\code{\\link[dplyr]{summarise_all}}, \n#'   \\code{\\link[dplyr]{summarise_at}}, \\code{\\link[dplyr]{summarise_if}}\n#' \n#' @examples \n#' practice_data <- \n#'   data.frame(\n#'   A = c(1:4, NA), \n#'   B = c(NA, 7:10), \n#'   C = 21:25,\n#'   G = c(1, 1, 1, 2, 2)\n#' )\n#' \n#' # Use the _qc versions just like normal dplyr scoped summarize functions.\n#' summarize_at_qc(\n#'   practice_data, \n#'   vars(A, C), \n#'   funs(m = mean(., na.rm = T), s = sum)\n#' )\n#' \n#' summarize_all_qc(practice_data, funs(mean))\n#' \n#' # Pipes work, just as they always do in dplyr\n#' practice_data %>% summarize_if_qc(is.integer, mean)\n#' \n#' # Functions work on grouped data, too\n#' grouped_data <- group_by(practice_data, G)\n#' grouped_data %>% \n#'   summarize_at_qc(vars(A, C), funs(m = mean(., na.rm = T), s = sum))\n#' \n#' # Setting .group_check = T will print, for each group with a missing value,\n#' # which new variables are missing. \n#' summarize_all_qc(grouped_data, mean, .group_check = T)\n#' \n#' @name summarize_all_qc\nNULL\n\n\n# HELPER FUNCTIONS ------------------------------------------------------------- \n\n# A function to count and print number of missing entries in final columns\nna_counter_sum <- function(.orig_data = NULL, .processed_data = NULL) {\n\n  # Dropping group variables from being printed, if any.\n  group_var <- attr(.orig_data, \"vars\")\n  keep_vars <- names(.processed_data)[!names(.processed_data) %in% group_var]\n  new_vars_data <- dplyr::ungroup(.processed_data)\n  new_vars_data <- dplyr::select_at(new_vars_data, keep_vars)\n  \n  # Counting number of NAs in each newly created variable\n  num_na <- \n    dplyr::summarize_all(\n      new_vars_data, \n      dplyr::funs(sum(is.na(.) | is.infinite(.)))\n    )\n  \n  mapply(\n    FUN = function(x, y) message(x, \" NAs or INFs produced in \", y), \n    x = num_na, y = names(num_na)\n  )\n\n}\n\n# A function to print missing variables for each group (with n >1 missing vars)\nna_counter_grp_sum <- function(.orig_data = NULL, .processed_data = NULL) {\n  \n  # Obtaining names of original group variables and grouping processed data by \n  # them\n  group_vars <- attr(.orig_data, \"vars\")\n  # processed_data <- dplyr::group_by_at(.processed_data, group_vars)\n\n  # Keep just rows with missing variables on new vars and\n  new_vars <- names(.processed_data)[!names(.processed_data) %in% group_vars]\n  g_with_missing <- \n    dplyr::filter(.processed_data, !complete.cases(.processed_data[, new_vars]))\n  \n  # Reshape data so just one variable for each row, which lists missing \n  # variables\n  g_with_missing <- \n    tidyr::gather(\n      g_with_missing,\n      key = key,\n      value = value,\n      new_vars\n    )\n  \n  g_with_missing <- dplyr::filter(g_with_missing, is.na(value) | is.infinite(value))\n  g_with_missing <- dplyr::group_by_at(g_with_missing, group_vars)\n  g_with_missing <- dplyr::summarize(g_with_missing, missing_vars = paste0(key, collapse = \", \"))\n  g_with_missing <- dplyr::ungroup(g_with_missing)\n\n  if (dplyr::tally(g_with_missing) > 0) {\n    message(\"\\n\", \"GROUPS WITH MISSING VALUES:\")\n    print.data.frame(g_with_missing)\n    message(\"\\n\")\n  } else {\n    message(\"\\n\", \"No missing values in any group in newly summarized variables\")\n    message(\"\\n\")\n  }\n  \n}\n\n\n# EXPORTED FUNCTIONS ----------------------------------------------------------- \n\n#' @rdname summarize_all_qc\n#' @export\nsummarize_all_qc <- function(.tbl, .funs, ..., .group_check = F) {\n    \n  # Check to make sure data is grouped if .group_check = T\n  if (.group_check == T & is.null(attr(.tbl, \"vars\"))) {\n    stop(\"Data is not grouped, so you cannot have .group_check = T\")\n  }\n  \n  # Preparing arguments to pass to functions\n  nv_pairs <- rlang::quos(...) \n  .args <- c(list(\".tbl\" = .tbl, \".funs\" = .funs), nv_pairs)\n  \n  # Performing summarize\n  out <- do.call(dplyr::summarize_all, .args)\n  \n  # Print NAs and return outcome\n  na_counter_sum(.orig_data = .tbl, .processed_data = out)\n  \n  if (.group_check == T) {\n    na_counter_grp_sum(.orig_data = .tbl, .processed_data = out)\n  }\n  \n  return(out)\n  \n}\n\n#' @rdname summarize_all_qc\n#' @export\nsummarise_all_qc <- function(.tbl, .funs, ..., .group_check = F) {\n\n  # Preparing arguments to pass to functions\n  nv_pairs <- rlang::quos(...) \n  args <- c(list(\".tbl\" = .tbl, \".funs\" = .funs, \".group_check\" = .group_check), nv_pairs)\n  \n  # Calling function\n  do.call(summarize_all_qc, args)\n  \n}\n\n#' @rdname summarize_all_qc\n#' @export\nsummarize_at_qc <- function(.tbl, .vars, .funs, ..., .cols = NULL, .group_check = F) {\n  \n  # Check to make sure data is grouped if .group_check = T\n  if (.group_check == T & is.null(attr(.tbl, \"vars\"))) {\n    stop(\"Data is not grouped, so you cannot have .group_check = T\")\n  }\n  \n  # Preparing arguments to pass to functions\n  nv_pairs <- rlang::quos(...) \n  .args <- c(\n    list(\".tbl\" = .tbl, \".vars\" = .vars, \".funs\" = .funs), \n    nv_pairs,\n    list(\".cols\" = .cols)\n  )\n  \n  # Performing summarize\n  out <- do.call(dplyr::summarize_at, .args)\n  \n  # Print NAs and return outcome\n  na_counter_sum(.orig_data = .tbl, .processed_data = out)\n  if (.group_check == T) {\n    na_counter_grp_sum(.orig_data = .tbl, .processed_data = out)\n  }\n  \n  return(out)\n  \n}\n\n#' @rdname summarize_all_qc\n#' @export\nsummarise_at_qc <- function(.tbl, .vars, .funs, ..., .cols = NULL, .group_check = F) {\n\n  # Preparing arguments to pass to functions\n  nv_pairs <- rlang::quos(...) \n  args <- c(\n    list(\".tbl\" = .tbl, \".vars\" = .vars, \".funs\" = .funs), \n    nv_pairs,\n    list(\".cols\" = .cols, \".group_check\" = .group_check)\n  )\n  \n  # Calling function\n  do.call(summarize_at_qc, args)\n  \n}\n\n\n#' @rdname summarize_all_qc\n#' @export\nsummarize_if_qc <- function(.tbl, .predicate, .funs, ..., .group_check = F){\n  \n  # Check to make sure data is grouped if .group_check = T\n  if (.group_check == T & is.null(attr(.tbl, \"vars\"))) {\n    stop(\"Data is not grouped, so you cannot have .group_check = T\")\n  }\n  \n  # Preparing arguments to pass to functions\n  nv_pairs <- rlang::quos(...) \n  .args <- c(\n    list(\".tbl\" = .tbl, \".predicate\" = .predicate, \".funs\" = .funs), \n    nv_pairs\n  )\n  \n  # Performing summarize\n  out <- do.call(dplyr::summarize_if, .args)\n  \n  # Print NAs and return outcome\n  na_counter_sum(.orig_data = .tbl, .processed_data = out)\n  if (.group_check == T) {\n    na_counter_grp_sum(.orig_data = .tbl, .processed_data = out)\n  }\n  \n  return(out)\n  \n}\n\n#' @rdname summarize_all_qc\n#' @export\nsummarise_if_qc <- function(.tbl, .predicate, .funs, ..., .group_check = F){\n  \n  # Preparing arguments to pass to functions\n  nv_pairs <- rlang::quos(...) \n  args <- c(\n    list(\".tbl\" = .tbl, \".predicate\" = .predicate, \".funs\" = .funs, \".group_check\" = .group_check), \n    nv_pairs\n  )\n  \n  # Calling function\n  do.call(summarize_at_qc, args)\n  \n}",
    "created" : 1519659241589.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "173633608",
    "id" : "5799BF72",
    "lastKnownWriteTime" : 1519660122,
    "last_content_update" : 1519660122282,
    "path" : "~/GitHub/reviewr_2/R/summarize_scoped_qc.R",
    "project_path" : "R/summarize_scoped_qc.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}