{
    "collab_server" : "",
    "contents" : "#' Report number of dropped cases when performing dplyr filter.\n#' \n#' \\code{filter_qc} returns an identical object as \\code{dplyr::filter}, except\n#'   that it automatically prints the number of cases (i.e., rows) that do not \n#'   meet the filter conditions and that were thus dropped.\n#' \n#' @section Scoped variants:\n#'   There are \\code{_qc} versions of the scoped filter functions. See \n#'   \\code{\\link{filter_at_qc}}, \\code{\\link{filter_all_qc}}, or\n#'   \\code{\\link{filter_if_qc}}.\n#'   \n#'   \n#' @inheritParams dplyr::filter\n#' \n#' @param .group_check a logical value, that when TRUE, will print a table with\n#' each group variable and columns called \"n_rows_dropped\" and \"percent_dropped\" \n#' that together indicate, for each group, how many row were dropped when \n#' performing filter. Default is FALSE, to avoid excess printing. If data is not\n#' grouped and .group_check = T, then an error is thrown.\n#'   \n#' @return An object of the same class as \\code{.data}. This object will be\n#'   identical to that which is returned when running the standard \n#'   \\code{dplyr::filter} function.\n#' \n#' @seealso \\code{\\link[dplyr]{filter}}\n#' \n#' @examples \n#' practice_data <- \n#'   data.frame(\n#'     A = 1:12, \n#'     B = 6:17, \n#'     C = 8:19, \n#'     G = c(rep(c(\"A\", \"B\"), each = 6)),\n#'     stringsAsFactors = F\n#'   )\n#' \n#' # Basic filtering\n#' filter_qc(practice_data, A > 5)\n#' filter_qc(practice_data, A > 5 & B > 8)\n#' \n#' # With grouped data and setting .group_check = T, you can see how many rows\n#' # were dropped per group. Note that this will print a large table if you have \n#' # a lot of groups.\n#' grouped_data <- group_by(practice_data, G)\n#' filter_qc(grouped_data, A > 3, .group_check = T)\n\nfilter_qc <- function(.data, ..., .group_check = F){\n  \n  # Check to make sure data is grouped if .group_check = T\n  if (.group_check == T & is.null(attr(.data, \"vars\"))) {\n    stop(\"Data is not grouped, so you cannot have .group_check = T\")\n  }\n  \n  # Preparing arguments to pass to function\n  conditions <- rlang::quos(...) \n  .args <- c(list(\".data\" = .data), conditions)\n  \n  # Performing filter and counting remaining rows\n  out <- do.call(dplyr::filter, .args)\n  out_nogrp <- dplyr::ungroup(out)\n  final_rows <- dplyr::tally(out_nogrp, wt = NULL)\n  \n  # Counting initial rows\n  init_nogrp <- dplyr::ungroup(.data)\n  init_rows <- dplyr::tally(init_nogrp, wt = NULL)\n  \n  # Preparing filter conditions for message\n  args_dots <- .args\n  args_dots$.data <- NULL\n  names(args_dots) <- NULL\n  \n  args_string <- gsub(\"list\\\\(|\", \"\", deparse(substitute(args_dots)))\n  args_string <- gsub(\"~\", \"\", args_string)\n  args_string <- substr(args_string, 1, nchar(args_string) - 1)\n  args_string\n  \n  # Printing filter diagnostics and returning filtered data\n  message(\n    init_rows - final_rows, \n    \" Rows dropped (\",\n    round(100 * (init_rows - final_rows) / init_rows, 1),\n    \"%), after filtering on: \",\n    args_string\n  )\n  \n  # Printing number of rows dropped per group if .group_check = T\n  if (.group_check == T) {\n    \n    # Number of final rows per group\n    final_grp <- dplyr::tally(out, wt = NULL)\n    names(final_grp)[length(names(final_grp))] <- \".final.\"\n    \n    # Number of intial rows per group\n    init_grp <- dplyr::tally(.data, wt = NULL)\n    names(init_grp)[length(names(init_grp))] <- \".initial.\"\n    \n    # Merging togther and calculating rows dropped\n    merged_grp <- suppressMessages(dplyr::left_join(init_grp, final_grp))\n    merged_grp <- dplyr::mutate(\n      merged_grp, \n      .final. = ifelse(is.na(.final.), 0, .final.),\n      .diff. = .initial. - .final.,\n      .prop. = paste0(round(100 * .diff. / .initial., 1), \"%\")\n    )\n    merged_grp <- dplyr::select(merged_grp, -.final., -.initial.)\n    names(merged_grp)[(length(names(merged_grp)) - 1):length(names(merged_grp))] <- \n      c(\"n_rows_dropped\", \"percent_dropped\")\n    \n    # Printing grouped filter diagnostics and returning filtered data\n    message(\"\\n\", \"NUMBER OF ROWS DROPPED BY GROUP:\")\n    print.data.frame(merged_grp)\n    \n  }\n  \n  return(out)\n    \n}",
    "created" : 1519654808796.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4061518340",
    "id" : "8EA868C1",
    "lastKnownWriteTime" : 1519656365,
    "last_content_update" : 1519656365956,
    "path" : "~/GitHub/reviewr_2/R/filter_qc.R",
    "project_path" : "R/filter_qc.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}