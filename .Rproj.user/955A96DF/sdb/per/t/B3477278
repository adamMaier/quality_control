{
    "collab_server" : "",
    "contents" : "#' Report number of NAs created when performing dplyr summarize\n#' \n#' \\code{summarize_qc} is used exactly the same as \\code{dplyr::summarize} and \n#' requires all of the same arguments and returns an identical object. The only \n#' difference is that \\code{summarize_qc} prints a message indicating the number\n#' of NA or INFinite values created in the new summary variable(s). This is most\n#' useful when using on a grouped data frame.\n#' \n#' @section Scoped variants:\n#'   There are \\code{_qc} versions of the scoped summarize functions. See \n#'   \\code{\\link{summarize_at_qc}}, \\code{\\link{summarize_all_qc}}, or\n#'   \\code{\\link{summarize_if_qc}}.\n#'\n#' @section Grouping:\n#'   All functions work with grouped data.\n#'\n#' @section summarize vs. summarise:\n#'   There are \\code{_qc} versions of \\code{summarize} and \\code{summarise}.\n#'   But this is America, use a z!\n#'     \n#' @inheritParams dplyr::summarise\n#' \n#' @param .group_check a logical value, that when TRUE, will print a table with\n#' each group variable and a column called \"missing_vars\" that lists which \n#' variables are missing from the summarized data for each group. Only groups \n#' with at least one missing variable are listed. This has no effect on the \n#' returned object, and only prints information. Default is FALSE, to avoid\n#' excess printing. If data is not grouped and .group_check = T, then an error \n#' is thrown.\n#'   \n#' @return An object of the same class as \\code{.data}. This object will be\n#'   identical to that which is returned when running \\code{dplyr::summarise}.\n#' \n#' @seealso \\code{\\link[dplyr]{summarise}}\n#' \n#' @examples \n#' practice_data <- \n#'   data.frame(\n#'   A = c(1:4, NA), \n#'   B = c(NA, 7:10), \n#'   C = 21:25,\n#'   G = c(\"X\", \"X\", \"X\", \"Y\", \"Y\"),\n#'   stringsAsFactors = F\n#' )\n#' \n#' summarize_qc(practice_data, new_var_1 = mean(C), sum(A))\n#' summarize_qc(practice_data, new_var_1 = mean(C), sum(A, na.rm = T))\n#' \n#' # Pipes work\n#' practice_data %>% \n#'   summarize_qc(practice_data, new_var_1 = mean(C), sum(A, na.rm = T))\n#' \n#' # Functions worked on grouped data, too\n#' grouped_data <- dplyr::group_by(practice_data, G)\n#' summarize_qc(grouped_data, new_var_1 = mean(A), mean_b = mean(B), sum(C))\n#' \n#' # Setting .group_check = T will print, for each group with a missing value,\n#' which new variables are missing. \n#' summarize_qc(\n#'   grouped_data, \n#'   .group_check = T,\n#'   new_var_1 = mean(A),\n#'   mean_b = mean(B),\n#'   sum(C)\n#' )\n#' \nsummarize_qc <- function(.data = NULL, ..., .group_check = F) {\n\n  # Check to make sure data is grouped if .group_check = T\n  if (.group_check == T & is.null(attr(.data, \"vars\"))) {\n    stop(\"Data is not grouped, so you cannot have .group_check = T\")\n  }\n  \n  # Preparing arguments to pass to functions\n  name_value_pairs <- rlang::quos(...) \n  .args <- c(list(\".data\" = .data), name_value_pairs)\n  \n  # Performing summarize\n  out <- do.call(dplyr::summarize, .args)\n\n  # Dropping group variables from being printed, if any.\n  group_vars <- attr(.data, \"vars\")\n  keep_vars <- names(out)[!names(out) %in% group_vars]\n  \n  if (!is.null(group_vars)) {\n    num_na <- dplyr::ungroup(out)\n    num_na <- dplyr::select_at(num_na, keep_vars)\n  } else {\n    num_na <- out\n  }\n\n  # Counting number of NAs in each summarize call by making each new variable \n  # them counting NAs in each and storing as list element with appropriate var\n  # name.\n  num_na <- \n    dplyr::summarize_all(\n      num_na, \n      dplyr::funs(sum(is.na(.) | is.infinite(.)))\n    )\n      \n  mapply(\n    FUN = function(x, y) message(x, \" NAs or INFs produced in \", y), \n    x = num_na, y = names(num_na)\n  )\n\n  # Printing groups with missing values by summary variable if group_check\n  if (.group_check == T) {\n\n    # Keep just rows with missing variables on new vars\n    g_with_missing <- dplyr::mutate_all(out, dplyr::funs(ifelse(is.infinite(.), NA, .)))\n    g_with_missing <- dplyr::filter(g_with_missing, !complete.cases(g_with_missing[, keep_vars]))\n    \n    # Reshape data so just one variable for each row, which lists missing \n    # variables\n    g_with_missing <- \n      tidyr::gather(\n        g_with_missing,\n        key = key,\n        value = value,\n        keep_vars\n      )\n    \n    g_with_missing <- dplyr::filter(g_with_missing, is.na(value) | is.infinite(value))\n    g_with_missing <- dplyr::group_by_at(g_with_missing, group_vars)\n    g_with_missing <- dplyr::summarize(g_with_missing, missing_vars = paste0(key, collapse = \", \"))\n    g_with_missing <- dplyr::ungroup(g_with_missing)\n      \n    if (dplyr::tally(g_with_missing) > 0) {\n      message(\"\\n\", \"GROUPS WITH MISSING VALUES:\")\n      print.data.frame(g_with_missing)\n      message(\"\\n\")\n    } else {\n      message(\"\\n\", \"No missing values in any group in newly summarized variables\")\n      message(\"\\n\")\n    }\n\n  }\n  \n  return(out)\n  \n}\n\nsummarise_qc <- function(.data = NULL, ..., .group_check = F) {\n  \n  # Preparing arguments to pass to functions\n  name_value_pairs <- rlang::quos(...) \n  args <- c(list(\".data\" = .data, \".group_check\" = .group_check), name_value_pairs)\n  \n  # Calling function\n  do.call(summarize_qc, args)\n  \n}",
    "created" : 1519658932619.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1722779787",
    "id" : "B3477278",
    "lastKnownWriteTime" : 1519659839,
    "last_content_update" : 1519659839331,
    "path" : "~/GitHub/reviewr_2/R/summarize_qc.R",
    "project_path" : "R/summarize_qc.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}