{
    "collab_server" : "",
    "contents" : "#' Report number of matched and/or extra cases when performing a dplyr join\n#' \n#' \\code{full_join_qc}, \\code{inner_join}, \\code{left_join}, \\code{right_join}, \n#'   \\code{anti_join}, and \\code{semi_join} return by default near identical \n#'   objects as their dplyr equivalents.\n#' \n#' Each _qc version of the join functions is identical to its dplyr equivalent\n#' except that it automatically prints the number of rows that were matched, the\n#' number of rows that were not matched, and the number of additional rows \n#' compared to the initial data frame(s) - for example when there is more than\n#' one match on the \\code{by} identifier(s). There are also options to create\n#' new variables identifying and classifying rows based on how/if they matched.\n#'\n#' @section Join Descriptions: \n#'   All joins except \\code{anti_join} and \\code{semi_join} are classified as\n#'   one to one, one to many, many to one, or many to many. These definitions\n#'   describe the extent to which there are duplicated rows of unique \n#'   combinations of the \\code{by} variable(s). In one to one merges, there is\n#'   only one unique row of identifiers in each data set. Extra rows are never \n#'   created in one to one joins. One to many and many to one joins occur when\n#'   one of the data sets has a duplicated id row. One to many implies the right \n#'   data has the duplicated id; many to one implies the left data has the \n#'   duplicated id. Additional rows may be created in these types of joins. Many\n#'   to many joins imply that both data sets have duplicated rows on the id\n#'   variable(s). Additional rows may be created in this types of join. The\n#'   join description is printed when performing any join except \n#'   \\code{anti_join} and \\code{semi_join}.\n#'   \n#' @section Optional New Variables:\n#'   For \\code{full_join_qc}, \\code{left_join_qc}, and \\code{right_join_qc}, \n#'   there is an added option of creating a new variable that indicates whether \n#'   the row in the joined data was from the \\code{\"left_only\"}, \n#'   \\code{\"right_only\"} or \\code{\"matched\"}. This variable can be helpful when\n#'   diagnosing why the join did or did not match as desired. Whatever character \n#'   value that is supplied to \\code{.merge} becomes the name of this new\n#'   variable.\n#' \n#'   \\code{left_join_qc}, and \\code{right_join_qc} also have the option of \n#'   creating a new variable indicating whether the row in the  joined data is \n#'   an additional row with the given combination of \\code{by}. For example, if\n#'   there were only 2 rows with an ID equal to \"A\" in the original left data \n#'   but 3 rows with this ID in the right data set, then the left joined data \n#'   will have more rows with this ID than the original left. \\code{.extra} is \n#'   a chracter value that when supplied becomes the name of this new variable\n#'   flagging a row  that has additional rows than the original left \n#'   or right data frame.\n#' \n#' @section Grouping:\n#'   Groups in the data frames are ignored for the purpose of joining, but the \n#'   result preserves the grouping of \\code{x}.\n#' \n#' @inheritParams dplyr::join\n#' \n#' @param .merge a character value used to name a new character variable, which\n#'   tracks the source of each row of the new, joined data. If \\code{NULL}, the\n#'   default, no new merge-tracking variable will be created. An error will\n#'   occur if a variable is already named the value specified in\\code{.merge}, \n#'   so make sure to choose different names for different joins.\n#'   \n#' @param .extra a character value used to name a new character variable, which \n#'   identifies any row of the new joined data that represents a combination of\n#'   the \\code{by} identifiers that has more rows than the original left and/or \n#'   right data frames. If \\code{NULL}, the default, no new extra row tracking \n#'   variable will be created. An error will occur if a variable is already \n#'   named the value specified in\\code{.extra}, so make sure to choose different\n#'   names for different joins.\n#' \n#' @seealso \\code{\\link[dplyr]{join}}\n#' \n#' @examples\n#' data_A <- \n#'   data.frame(\n#'     id = 1:10, \n#'     var_A = 11:20\n#'    )\n#' data_B <- \n#'   data.frame(\n#'     id = c(5, 5, 5, 5, 6, 7, 7, 9, 10, 11), \n#'     id_A = c(1:10), \n#'     var_B = 21:30\n#'   )\n#' \n#' # Full join with new .merge variable\n#' full_join_qc(data_A, data_B, .merge = \"merge_ab\")\n#' \n#' # Left join with new .extra variable\n#' left_join_qc(data_A, data_B, .extra = \"extra_ab\")\n#' \n#' # Right join with both new variables\n#' right_join_qc(data_A, data_B, .merge = \"merge_ab\", .extra = \"extra_ab\")\n#' \n#' @name join_qc\nNULL\n\n\n\n# HELPER FUNCTIONS -------------------------------------------------------------\n\n# This function performs the join based on which function called it and prints\n# all of the standard diagnoses\njoin_dispatch <- function(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"),\n                          .merge = NULL, .extra = NULL, ...) {\n  \n  # Removing all group attributes from tables, but keeping group of x to \n  # re-apply after merge\n  x_group <- attr(x, \"vars\")\n  x <- dplyr::ungroup(x)\n  y <- dplyr::ungroup(y)\n  \n  # Checking if tracker variables already used. Only a warning is provided if so\n  if (\".x_tracker\" %in% names(x)) {\n    message(\"Warning: variable .x_tracker in left table was dropped\")\n  }\n  if (\".y_tracker\" %in% names(y)) {\n    message(\"Warning: variable .y_tracker in right table was dropped\")\n  }\n  \n  # Stopping function if name supplied to .merge or .extra already in use\n  if (!is.null(.merge)) {\n    if (.merge %in% names(x) | .merge %in% names(y)) {\n      stop(\n        paste0(\n          \"Column '\", \n          .merge, \n          \"' already exists; change .merge name before proceeding\"\n        )\n      )\n    }\n  }\n  \n  if (!is.null(.extra)) {\n    if (.extra %in% names(x) | .extra %in% names(y)) {\n      stop(\n        paste0(\n          \"Column '\", \n          .extra, \n          \"' already exists; change .extra name before proceeding\"\n        )\n      )\n    }\n  }\n  \n  # Adding simple merge tracker variables to tables\n  x <- dplyr::mutate(x, .x_tracker = T)\n  y <- dplyr::mutate(y, .y_tracker = T)\n  \n  # Extracting matched variables from left and from right\n  if (is.null(by)) {\n    matched_vars_left <- names(x)[names(x) %in% names(y)]\n    matched_vars_right <- matched_vars_left\n  } else if (is.null(names(by))) {\n    matched_vars_left <- by\n    matched_vars_right <- by\n  } else {\n    matched_vars_left <- ifelse(grepl(\".\", names(by)), names(by), unname(by))\n    matched_vars_right <- unname(by)\n  }\n  \n  # Creating by reversal\n  if (all.equal(matched_vars_left, matched_vars_right) != T) {\n    by_reverse <- matched_vars_left\n    names(by_reverse) <- matched_vars_right\n  } else {\n    by_reverse <- by\n  }\n  \n  # Identifying type of merge that occured\n  left_type <- max(duplicated(x[, matched_vars_left]))\n  right_type <- max(duplicated(y[, matched_vars_right]))\n  if (left_type == 0) left_type <- \"ONE\" else left_type <- \"MANY\"\n  if (right_type == 0) right_type <- \"ONE\" else right_type <- \"MANY\"\n  join_type <- paste(\"This was a\", left_type, \"TO\", right_type, \"join\")\n\n  \n  # Doing join based on which qc function is calling. Going up two levels in\n  # sys.call because qc join functions called using do.call\n  fn_name <- gsub(\"\\\\(.*\", \"\", deparse(sys.call(-2)[[1]]))\n  \n  if (fn_name == \"full_join_qc\") {\n    joined <- dplyr::full_join(x = x, y = y, by = by, copy = copy, \n                               suffix = suffix, ... = ...)\n  }\n  \n  if (fn_name == \"inner_join_qc\") {\n    joined <- dplyr::inner_join(x = x, y = y, by = by, copy = copy, \n                                suffix = suffix, ... = ...)\n  }\n  \n  if (fn_name == \"left_join_qc\") {\n    joined <- dplyr::left_join(x = x, y = y, by = by, copy = copy, \n                               suffix = suffix, ... = ...)\n  }\n  \n  if (fn_name == \"right_join_qc\") {\n    joined <- dplyr::right_join(x = x, y = y, by = by, copy = copy, \n                                suffix = suffix, ... = ...)\n  }\n  \n  # Calculating number of matches in newly joined data\n  matched <- dplyr::tally(joined, !is.na(.x_tracker) & !is.na(.y_tracker))\n  unmatched_x <- dplyr::tally(joined, !is.na(.x_tracker) & is.na(.y_tracker))\n  unmatched_y <- dplyr::tally(joined, is.na(.x_tracker) & !is.na(.y_tracker))\n  total <- dplyr::tally(joined)\n  \n  # Percent of rows from each data set that matched\n  matched_ids <- dplyr::filter(joined, !is.na(.x_tracker) & !is.na(.y_tracker))\n  matched_ids <- dplyr::select_at(matched_ids, matched_vars_left)\n  matched_ids_x <- dplyr::distinct(matched_ids)\n  matched_ids_y <- matched_ids_x\n  names(matched_ids_y) <- matched_vars_right\n  \n  matched_percent_x <- suppressMessages(dplyr::inner_join(x, matched_ids_x))\n  matched_percent_x <- dplyr::tally(matched_percent_x) / dplyr::tally(x) \n  matched_percent_x <- 100 * round(matched_percent_x, 3)\n  matched_percent_y <- suppressMessages(dplyr::inner_join(y, matched_ids_y))\n  matched_percent_y <- dplyr::tally(matched_percent_y) / dplyr::tally(x) \n  matched_percent_y <- 100 * round(matched_percent_y, 3)\n  \n  # Counting extra rows created\n  anti_n_x <- dplyr::tally(\n    suppressMessages(\n      dplyr::anti_join(x, y, by = by, suffix = suffix,  ... = ...)\n    )\n  )\n  anti_n_y <- dplyr::tally(\n    suppressMessages(\n      dplyr::anti_join(y, x, by = by_reverse, suffix = suffix, ... = ...)\n    )\n  )\n  extra_rows_x <- matched - (dplyr::tally(x) - anti_n_x)\n  extra_rows_y <- matched - (dplyr::tally(y) - anti_n_y)\n  \n  # Print merge diagnoses\n  message(\n    \"\\n\",\n    join_type, \"\\n\",\n    \"\\n\",\n    \"MATCH DISTRIBUTION IN JOINED DATA\\n\",\n    matched, \" (\", 100 * round(matched / total, 3), \"%) Rows are matches\", \"\\n\",\n    unmatched_x, \" (\", 100 * round(unmatched_x / total, 3), \"%) Rows are from left only\", \"\\n\",\n    unmatched_y, \" (\", 100 * round(unmatched_y / total, 3), \"%) Rows are from right only\", \"\\n\",\n    \"\\n\",\n    \"MATCH RATES BASED ON ORIGINAL DATA\\n\",\n    matched_percent_x, \"% Percent of rows from left matched\" ,\"\\n\",\n    matched_percent_y, \"% Percent of rows from right matched\", \"\\n\",\n    \"\\n\",\n    \"ADDITIONAL ROWS\\n\",\n    extra_rows_x, \" More rows with a matched ID than original left\", \"\\n\",\n    extra_rows_y, \" More rows with a matched ID than original right\"\n  )\n  \n  # Create .merge variable if specified. This is the only part of the code\n  # that requires rlang. Could not figure out how to implement := otherwise\n  if (!is.null(.merge)) {\n    joined <- \n      dplyr::mutate(\n        joined,\n        rlang::UQ(.merge) :=\n          dplyr::case_when(\n            !is.na(joined$.x_tracker) & is.na(joined$.y_tracker) ~ \"left_only\",\n            is.na(joined$.x_tracker) & !is.na(joined$.y_tracker) ~ \"right_only\",\n            TRUE ~ \"matched\"\n          )\n      )\n  }\n  \n  # Dropping tracker variables\n  joined <- dplyr::select(joined, -.x_tracker, -.y_tracker)\n  \n  # Create .extra variable if specified.\n  # In a full join, extra rows can happen when not a 1-1 merge\n  if (!is.null(.extra)) {\n    \n    # Isolate combinations of ID varaibles in left/right table with more than one,\n    # then change column names to match opposite data table.\n    x_count <- dplyr::group_by_at(x, matched_vars_left)\n    x_count <- dplyr::summarize(x_count, .x_tracker = n())\n    x_count <- dplyr::ungroup(x_count)\n    x_count <- dplyr::filter(x_count, .x_tracker > 1)\n    x_count <- dplyr::select(x_count, -.x_tracker)\n    names(x_count) <- matched_vars_right\n    y_extra <- suppressMessages(dplyr::semi_join(x_count, y))\n    y_extra <- dplyr::mutate(y_extra, .y_tracker = T)\n    \n    y_count <- dplyr::group_by_at(y, matched_vars_right)\n    y_count <- dplyr::summarize(y_count, .y_tracker = n())\n    y_count <- dplyr::ungroup(y_count)\n    y_count <- dplyr::filter(y_count, .y_tracker > 1)\n    y_count <- dplyr::select(y_count, -.y_tracker)\n    names(y_count) <- matched_vars_left\n    x_extra <- suppressMessages(dplyr::semi_join(y_count, x))\n    x_extra <- dplyr::mutate(x_extra, .x_tracker = T)\n    \n    # Match identified extra rows in joined data. Need to do this in two ways in \n    # case extra rows is an empty data frame\n    if(dplyr::tally(x_extra) > 0) {\n      joined <- suppressMessages(\n        dplyr::left_join(joined, x_extra, by = matched_vars_left)\n      )\n    } else {\n      joined <- dplyr::mutate(joined, .x_tracker = NA)\n    }\n    \n    if(dplyr::tally(y_extra) > 0) {\n      joined <- suppressMessages(\n        dplyr::left_join(joined, y_extra, by = matched_vars_right)\n      )\n    } else {\n      joined <- dplyr::mutate(joined, .y_tracker = NA)\n    }\n    \n    # Renaming extra variables based on condition. \n    joined <- \n      dplyr::mutate(\n        joined,\n        rlang::UQ(.extra) :=\n          dplyr::case_when(\n            joined$.x_tracker & joined$.y_tracker ~ \"extra_on_both\",\n            joined$.x_tracker & is.na(joined$.y_tracker) ~ \"extra_on_left\",\n            is.na(joined$.x_tracker) & joined$.y_tracker ~ \"extra_on_right\",\n            TRUE ~ \"not_extra\"\n          )\n      )\n    \n    # Return joined data with new .extra variable and dropped tracker variables\n    joined <- dplyr::select(joined, -.x_tracker, -.y_tracker)\n  \n  }\n  \n  # Regroup data and return\n  if (!is.null(x_group)) joined <- dplyr::group_by_at(joined, x_group)\n  return(joined)\n  \n}\n\n\n\n# EXPORTED FUNCTIONS -----------------------------------------------------------\n\n#' @rdname join_qc\n#' @export\nfull_join_qc <- function(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"),\n                         .merge = NULL, .extra = NULL, ...){\n  .args <- as.list(match.call()[-1])\n  do.call(join_dispatch, .args)\n}\n\n#' @rdname join_qc\n#' @export\ninner_join_qc <- function(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"),\n                         .merge = NULL, .extra = NULL, ...){\n  .args <- as.list(match.call()[-1])\n  do.call(join_dispatch, .args)\n}\n\n#' @rdname join_qc\n#' @export\nleft_join_qc <- function(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"),\n                         .merge = NULL, .extra = NULL, ...){\n  .args <- as.list(match.call()[-1])\n  do.call(join_dispatch, .args)\n}\n\n#' @rdname join_qc\n#' @export\nright_join_qc <- function(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"),\n                         .merge = NULL, .extra = NULL, ...){\n  .args <- as.list(match.call()[-1])\n  do.call(join_dispatch, .args)\n}\n\n#' @rdname join_qc\n#' @export\nanti_join_qc <- function(x, y, by = NULL, copy = FALSE, ...){\n    \n    # Doing join\n    anti_joined <- dplyr::anti_join(x, y, by = by, suffix = suffix, ... = ...)\n\n    # Calculating merge diagnoses \n    unmatched_x <- dplyr::tally(x) - dplyr::tally(anti_joined)\n\n    # Print merge diagnoses\n    message(\n        \"\\n\",\n        \"Anti joins only keep matching cases, so no match diagnosis\", \"\\n\",\n        \"Anti joins never create extra rows, so now additional row diagnosis\", \"\\n\",\n        \"\\n\",\n        \"DROPPED ROWS\", \"\\n\",\n        unmatched_x, \" Rows were dropped from left\"\n    )\n    \n    # Returning data frame\n    return(anti_joined)\n    \n}\n\n#' @rdname join_qc\n#' @export\nsemi_join_qc <- function(x, y, by = NULL, copy = FALSE, ...){\n    \n    # Doing join\n    joined <- dplyr::semi_join(x, y, by = by, suffix = suffix, ... = ...)\n    \n    # Calculating merge diagnoses \n    unmatched_x <- dplyr::tally(x) - dplyr::tally(joined)\n    \n    # Print merge diagnoses\n    message(\n        \"\\n\",\n        \"Semi joins only keep matching cases, so no match diagnosis\", \"\\n\",\n        \"Semi joins never create extra rows, so now additional row diagnosis\", \"\\n\",\n        \"\\n\",\n        \"DROPPED ROWS\", \"\\n\",\n        unmatched_x, \" Rows were dropped from left\"\n    )\n    \n    # Rreturning data frame\n    return(joined)\n    \n}",
    "created" : 1519660233694.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3675428215",
    "id" : "E77E9570",
    "lastKnownWriteTime" : 1519660403,
    "last_content_update" : 1519660403992,
    "path" : "~/GitHub/reviewr_2/R/join_qc.R",
    "project_path" : "R/join_qc.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}