% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_qc.R
\name{filter_qc}
\alias{filter_qc}
\alias{filter_qc}
\title{Report number of dropped cases when performing dplyr filter.}
\usage{
filter_qc(.data, ..., .group_check = F)
}
\arguments{
\item{.data}{A tbl. All main verbs are S3 generics and provide methods
for \code{\link[=tbl_df]{tbl_df()}}, \code{\link[dtplyr:tbl_dt]{dtplyr::tbl_dt()}} and \code{\link[dbplyr:tbl_dbi]{dbplyr::tbl_dbi()}}.}

\item{...}{Logical predicates defined in terms of the variables in \code{.data}.
Multiple conditions are combined with \code{&}. Only rows where the
condition evaluates to \code{TRUE} are kept.

These arguments are automatically \link[rlang:quo]{quoted} and
\link[rlang:eval_tidy]{evaluated} in the context of the data
frame. They support \link[rlang:quasiquotation]{unquoting} and
splicing. See \code{vignette("programming")} for an introduction to
these concepts.}

\item{.group_check}{a logical value, that when TRUE, will print a table with
each group variable and columns called "n_rows_dropped" and "percent_dropped" 
that together indicate, for each group, how many row were dropped when 
performing filter. Default is FALSE, to avoid excess printing. If data is not
grouped and .group_check = T, then an error is thrown.}
}
\value{
An object of the same class as \code{.data}. This object will be
  identical to that which is returned when running the standard 
  \code{dplyr::filter} function.
}
\description{
\code{filter_qc} returns an identical object as \code{dplyr::filter}, except
  that it automatically prints the number of cases (i.e., rows) that do not 
  meet the filter conditions and that were thus dropped.
}
\section{Scoped variants}{

  There are \code{_qc} versions of the scoped filter functions. See 
  \code{\link{filter_at_qc}}, \code{\link{filter_all_qc}}, or
  \code{\link{filter_if_qc}}.
}

\examples{
practice_data <- 
  data.frame(
    A = 1:12, 
    B = 6:17, 
    C = 8:19, 
    G = c(rep(c("A", "B"), each = 6)),
    stringsAsFactors = F
  )

# Basic filtering
filter_qc(practice_data, A > 5)
filter_qc(practice_data, A > 5 & B > 8)

# With grouped data and setting .group_check = T, you can see how many rows
# were dropped per group. Note that this will print a large table if you have 
# a lot of groups.
grouped_data <- group_by(practice_data, G)
filter_qc(grouped_data, A > 3, .group_check = T)

}
\seealso{
\code{\link[dplyr]{filter}}
}
